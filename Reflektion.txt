Först så började jag med HTML:et, la up dem semantiska elementen och sedan innehållselementen tillsammans med deras respektive innehåll (bestående av headings, paragraphs och links). Jag började där för min egen skull för att bli mer orienterad. För att ha en grund att stå på och börja med, så att säga. Den grunden blev sidans layout av dess innehåll i min HTML (alltså inte layouten av var de olika elementen skulle bli placerade, vilket sker senare i CSS-delen). Jag skulle nu lättare kunna ana/visualisera vad exakt det är som saknas i "bilden" och som behövs läggas till genom min script som jag inte hade lagt till genom min HTML. Nämligen, input:en och knapparna tillsammans med deras medföljande text outputs.
   Jag visste att jag ville ha min inloggning i headern bredvid sidans huvudtitel och såg till att lägga en div i min HTML för att illustrera detta fastän den lämnades tom genom hela uppgiftens gång och fastän den inte behövde vara där utan kunde skapas i min script. Men jag tyckte det var viktigt att ha hela sidans struktur synlig på en och samma plats för min egen skull men också för andras läsupplevelse; de behöver inte hoppa runt mellan filer för att få en hel överblick på den HTML-strukturen.

Nu skulle den div:en fyllas på, remote, från .js-filen, med inputs och knappar och text. Jag skulle antagligen ha kunnat lägga till en button och inserts till div:en i HTML och kunnat göra en variabel som refererar till dem med "getElementById". Men jag gillar inte det eftersom det får det att verka som att div:en är statisk och att dess innehåll inte kommer ändras. Om den lämnas tom, däremot, signaleras det till den som läser koden att den platsen väntar på att fyllas. Nu blev id:et för den div:en,"access-function", men jag skulle ha kunnat ha gjort id:et så att den talar om för läsaren att elementet styrs av min script genom att döpa om den till något som t.ex., "access-function-by-script", i stället. Eller lagt en kommentar inuti div:en som förklarar allt.
   Och det var varför jag la div:en i min HTML när det gäller potentiella kodgranskare. Men jag gjorde det också på det sättet för att underlätta för mig. Jag tog hänsyn till att dessa element (inputs och knappar och text) kommer att försvinna och uppenbara sig enligt interaktionen från användaren (knapptryck). Samtidigt visste jag om att det som sker i en funktion sker bara om den ropas på, så elementen kommer inte finnas om funktionen inte ropas på. Nu började jag förknippa knapparna (och deras innehåll) med funktioner. Perfekt. När användaren nu interagerar med knapparna så "kallar" dem egentligen på andra knappar, som nu är funktioner, för att ersätta dem knappar som redan finns på plats. Jag gjorde upp tre funktioner för varje knapp som skulle placeras ("placeLogin", "placeLogout" och "placeTryAgain") så att knapptrycken korresponderar med vilken funktion/knapp som ska sättas i kraft. Allt detta är till för att säga att jag create:ade mina element inom funktionerna eftersom det var visuellt vettigt. För att det är vad som händer på webbsidan när funktionerna kallas; web-browsern framställer elementen åt klienten. Och jag tyckte att det borde reflekteras i scripten i var dessa node-skapande metoder befann sig, nämligen i början av varje funktion. Om det relaterar till funktionen så kan det lika gärna ligga där så att man kan orientera sig i vad det är som händer när funktionen ropas på och vilka element det kommer ha påverkan på.
   
Jag vill också här lägga till att ta hänsyn till att allt det jag skrivit hittills handlat om att försöka ge kodgranskaren en enkel överblick av både HTML-filen och JS-filen utan att behöva hoppa runt mellan dem. Allt som relaterar till sidans interaktiva del ligger i scripten och i HTML-koden sätts allting som behövs för ett ge en helhetsbild av sidans innehåll.

Jag valde att orientera min Javascript enligt knapparna eftersom dem var den avgörande interaktiva delen av min sida. Jag gjorde först tre funktioner för varje knapp och när jag var klar med dem så gick jag tillbaka upp till toppen av min script och la en global if-sats som kommer checka localstorage vid varje ny page-refresh och tillämpa ett visst innehåll beroende på det som lagts/sparats (eller inte lagts/sparats) där.
   De metoder eller verktyg, eller vad man nu vill kalla det, som jag utnyttjade var: selektionssatser, funktioner, och localstorage. localstorage för att "spara" den funktion som gäller och sedan if-satser (koller efter vilken kod som ska köras eller hoppas över) med conditions som kollar efter vad som sparats/ klienten gjort för val för att avgöra hur satsen ska handla.
   
Det finns inte så mycket att säga om min CSS eftersom det är mest samma trick som jag använde i CV-uppgiften. Det enda som riktigt finns att kommentera är Flexbox-bitarna.
   Den första display:flex sattes i min container. Jag gjorde en container så att sidans innehåll hamnar helt inuti en div, i stället för att ha det "klistrat" på body:n. På detta sätt kan man enklare lägga till mer innehåll på body:n genom att lägga till fler containers (t.ex. en sidomeny) och sedan flexa dem när man satt en display:flex på body:n. Så vad gör den exakt? Inte mycket. Den sätter min header, contents-sida, och footer ovanpå varandra och centrerar dem längs den nu vågräta cross-axis.
   Den andra display:flex sätts på headern för att få titeln och inloggingsdiv:en på samma rad bredvid varandra mot höger sida så att titelns 50% width hamnar i linje med contents-sidans 50% width. Jag behövde göra inloggningsdiv:en till 25% width så det blir exakt samma 25% width tomrum på andra sidan titeln. Om du tänker från höger sida: inloggningsdiv:en 25% + titelns 50% blir 75% procent med 25% tomrum kvar på vänster sida om titeln. Sedan har align-self mot center lagts på både titeln och inloggningsdiv:en. De kommer sättas ovanpå den lodräta cross-axis:en eftersom flex-items är i row här i stället.
   Den sista display:flex hamnar på själva inloggningsdiv:en för att få inputs och knappen ovanpå varandra och sedan sätt dem mot vänster håll längs den vågräta cross-axis:en.
   Box-sizing lades till på footer för att få elementet tillsammans med dess margin och padding att hamna inom den 50%-widthen jag satte på den.
   Allt annat är spacing och utseende.

Jag tänker jag i stället redovisar för hur jag problemlöste den globala if-satsen uppe på toppen så att du kan få en känsla för hur jag tänker.
   Min globala if-sats har två ifs som den testar. Den första if kör bara om placeLogin-funktionen har fått rätt namn/lösen. I så fall ska den sätta placeLogout-funktionen på plats varenda gång sidan laddas om samtidigt som den ändrar texten som funktionen hela tiden returnerar så att den informerar att du är inloggad men som nu skippar på att välkomna dig.
   Vi kan hoppa över till else:n först. Om den inte finner rätt account-details i localstorage så ska den presentera dig med log-in inputs i stället. .replaceChildren-metoden är till för att tömma div:en innan de nya elementen sätts på plats.
   Else-if:en i mitten la jag till senare men behövdes verkligen inte. Den är till för att göra så att felmeddelandet visas fortfarande efter en sido-refresh, så att du måste trycka på "Try Again"-knappen för att gå tillbaka till placeLogin-funktionen och göra ett till försök. Detta åstadkoms när placeTryAgain-funktionen ropats på, då sparar den en key i localstorage. Om else-if:en hittar denna key så laddar den om felmeddelandet. När man trycker på själva "Try Again"-knappen rensas hela localstorage så att else-satsen körs eftersom båda ifs nu inte hittar någon true-value.
   Men det blir inte attraktivt eftersom det finns kvar även efter man stängt fönstret och öppnat det igen. Tar jag bort denna else-if så kan man få log-in inputs:en att komma tillbaka med en refresh och blir inte tvungen att trycka på "Try Again"-knappen, vilket är hur många sidor faktiskt har det.
